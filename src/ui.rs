/// UI utilities for elegant text dividers and styling with multi-color ASCII art

use colored::*;
use rand::prelude::*;

/// ASCII art categories from the gist
pub struct AsciiArtCategories;

impl AsciiArtCategories {
    /// Cute Sparkles category
    pub fn cute_sparkles() -> Vec<&'static str> {
        vec![
            "âœ§ï½¥ï¾Ÿ: *âœ§ï½¥ï¾Ÿ:* ã€€ã€€ *:ï½¥ï¾Ÿâœ§*:ï½¥ï¾Ÿâœ§",
            ".ãƒ»ã‚œã‚œãƒ»ã€€ã€€ãƒ»ã‚œã‚œãƒ»ï¼Ž",
            "ï½¡ï½¥ï¾Ÿï¾Ÿï½¥ã€€ã€€ï½¥ï¾Ÿï¾Ÿï½¥ï½¡",
            "à¼¶â€¢â”ˆâ”ˆâ›§â”ˆâ™› â™›â”ˆâ›§â”ˆâ”ˆâ€¢à¼¶",
            "âœ§à¼ºâ™¥à¼»âˆžã€€ã€€âˆžà¼ºâ™¥à¼»âœ§",
            "*ï¼Šâœ¿â€ã€€â€âœ¿ï¼Š*",
            "â‹† Ëšï½¡â‹†à­¨à­§Ëšã€€Ëšà­¨à­§â‹†ï½¡Ëš â‹†",
            "ï½¡oÂ°âœ¥âœ¤âœ£ ã€€ã€€ âœ£âœ¤âœ¥Â°oï½¡",
            "â™¬â™©â™ªâ™©ã€€ã€€â™©â™ªâ™©â™¬",
            "*:..ï½¡oâ—‹ã€€ã€€â—‹oï½¡..:*",
            "ï¾Ÿ+*:ê”«:*ï¹¤ã€€ã€€ï¹¥*:ê”«:*+ï¾Ÿ",
            "*+:ï½¡.ï½¡ã€€ã€€ï½¡.ï½¡:+*",
            "â™¥*â™¡âˆž:ï½¡.ï½¡ã€€ã€€ï½¡.ï½¡:âˆžâ™¡*â™¥",
            "â€§ÌÌŠË™ËšË™áµ•ê’³áµ•Ë™ËšË™ã€€ã€€Ë™ËšË™áµ•ê’³áµ•Ë™ËšË™â€§ÌÌŠ",
            "*Â°:â‹†â‚“â‚’ã€€ã€€â‚“â‚’â‹†:Â°*",
            "â‚“Ëš. à­­ Ëšâ—‹â—¦Ëš.Ëšâ—¦â—‹Ëš à­§ .Ëšâ‚“",
            "Ë‘à¼„Ø˜ ÛªÛªÛ«Û« â–¹â–«â—ƒ ÛªÛªÛ«Û« à¼„Ø˜ Ë‘",
            "Â° ðªð‘‚ â™¡ ðªð‘‚ â‚’ ðªð‘‚ â™¡ ðªð‘‚ Â°",
            "âˆž â‚’ Ëš Â° ð’ðš Â° Ëš â‚’ âˆž",
            "ï½¡â‚“ à¥‚ â‚’ à¥ Ëš à¥‚ â‚’ à¥ â‚“ï½¡",
            "â˜†â™¬â—‹â™©â—â™ªâœ§â™©ã€€ã€€â™©âœ§â™ªâ—â™©â—‹â™¬â˜†",
            "â­‘ï½¥ï¾Ÿï¾Ÿï½¥*:à¼…ï½¡.ï½¡à¼…:*ï¾Ÿ:*:âœ¼âœ¿ã€€ã€€âœ¿âœ¼:*ï¾Ÿ:à¼…ï½¡.ï½¡à¼…:*ï½¥ï¾Ÿï¾Ÿï½¥â­‘",
        ]
    }

    /// Galactic Sparkles category
    pub fn galactic_sparkles() -> Vec<&'static str> {
        vec![
            "ï½¡ï½¥:*:ï½¥ï¾Ÿâ˜…,ï½¡ï½¥:*:ï½¥ï¾Ÿâ˜†ã€€ã€€ ï½¡ï½¥:*:ï½¥ï¾Ÿâ˜…,ï½¡ï½¥:*:ï½¥ï¾Ÿâ˜†",
            ".ãƒ»ã‚œ-: âœ§ :-ã€€ã€€-: âœ§ :-ã‚œãƒ»ï¼Ž",
            "â‹‡â‹†âœ¦â‹†â‹‡ã€€ â‹‡â‹†âœ¦â‹†â‹‡",
            "â­’âƒ.âœ®:â–¹ã€€ã€€â—ƒ:âœ®.âƒâ­’",
            "â€§Í™âºËšï½¥à¼“â˜¾ã€€ã€€â˜½à¼“ï½¥Ëšâºâ€§Í™",
            ".ï½¡ï¾Ÿ+..ï½¡ã€€ã€€ã€€ï¾Ÿ+..ï½¡ï¾Ÿ+",
            "â˜†.ï½¡.:ã€€ã€€.ï½¡.:â˜†",
            "â˜†â—‹oã€‚ã€€ã€€ã€‚oâ—‹â˜†",
            ".â‹†ï½¡â‹†â˜‚Ëšï½¡â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†.",
            "â¤¹â‹†â¸™ÍŽÛ«Ûªï½¡ËšÛ°Ëšâ˜½Ëšâ€âž·ï½¡Ëšâ¸™ÍŽÛ«Ûªâ‹† à¼„",
            "Ø¹Ë–âº â˜â‹† à­­ ðŸ•Š.â‹†ï½¡â‹†à¼¶â‹†Ë™âŠ¹",
            "Ë ð“§ ð“² ð“² ð“² ð“‹’ ð“² ð“² ð“² ð“² ð“§ ËŽ",
            "â€§ÌÌŠË™Â· ð“†.Â° ï½¡Ëšð“†›Ëšï½¡ Â°.ð“†ž Â·Ë™â€§ÌÌŠ",
            "ï½¡ï¾ŸâÛªà½´ Â°â‚’ ð“‚‚ Ëš ð“‚‚ â‚’ Â° â‚’ ð“‚‚ ËšË–â‹†",
            "â‹†â”ˆâ”ˆï½¡ï¾ŸâƒÛªà½´ â€Ûªà½´ âÛªà½´ âƒÛªà½´ â€Ûªà½´ ï¾Ÿï½¡â”ˆâ”ˆâ‹†",
            ".ï½¡â…â‹†â‹âˆžï½¡âˆžâ‹â‹†â…ï½¡.",
            "â–¸ ðŸŽ• â”ˆâ”ˆâ”ˆâ”ˆ ðŸŽ• â”ˆâ”ˆâ”ˆâ”ˆ ðŸŽ• â—‚",
            "á ƒ âš˜á ‚ âš˜ Ëš âš˜ á ‚ âš˜ á ƒ",
            "ãƒ»â€¥â€¦â”â”â”â”â”â”â”â˜†â˜†â”â”â”â”â”â”â”â€¦â€¥ãƒ»",
            "ï½¡â˜†âœ¼â˜…â”â”â”â”â”â”â”â”â”â”â”â”â˜…âœ¼â˜†ï½¡",
            "â˜…ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»â˜…ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»â˜…ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»â˜…",
            "ã€â˜†ã€‘â˜…ã€â˜†ã€‘â˜…ã€â˜†ã€‘â˜…ã€â˜†ã€‘â˜…ã€â˜†ã€‘",
            "Â»Â»â€”â€”âŸâ€”â€”Â«Â«",
            ".ãƒ»ã€‚.ãƒ»ã‚œâœ­ãƒ».ãƒ»âœ«ãƒ»ã‚œãƒ»ã€‚.",
        ]
    }

    /// Nature mood category
    #[allow(dead_code)]
    pub fn nature_mood() -> Vec<&'static str> {
        vec![
            ".â‹†ï½¡â‹†â˜‚Ëšï½¡â‹†ï½¡Ëšâ˜½Ëšï½¡â‹†.",
            "â¤¹â‹†â¸™ÍŽÛªÛ«ï½¡ËšÛ°Ëšâ˜½Ëšâ€âž·ï½¡Ëšâ¸™ÍŽÛªÛ«â‹† à¼„",
            "Ø¹Ë–âº â˜â‹† à­­ ðŸ•Š.â‹†ï½¡â‹†à¼¶â‹†Ë™âŠ¹",
            "Ë ð“§ ð“² ð“² ð“² ð“‹’ ð“² ð“² ð“² ð“² ð“§ ËŽ",
            "â€§ÌÌŠË™Â· ð“†.Â° ï½¡Ëšð“†›Ëšï½¡ Â°.ð“†ž Â·Ë™â€§ÌÌŠ",
            "ï½¡ï¾ŸâÛªà½´ Â°â‚’ ð“‚‚ Ëš ð“‚‚ â‚’ Â° â‚’ ð“‚‚ ËšË–â‹†",
            "â‹†â”ˆâ”ˆï½¡ï¾ŸâƒÛªà½´ â€Ûªà½´ âÛªà½´ âƒÛªà½´ â€Ûªà½´ ï¾Ÿï½¡â”ˆâ”ˆâ‹†",
            ".ï½¡â…â‹†â‹âˆžï½¡âˆžâ‹â‹†â…ï½¡.",
            "â–¸ ðŸŽ• â”ˆâ”ˆâ”ˆâ”ˆ ðŸŽ• â”ˆâ”ˆâ”ˆâ”ˆ ðŸŽ• â—‚",
            "á ƒ âš˜á ‚ âš˜ Ëš âš˜ á ‚ âš˜ á ƒ",
        ]
    }

    /// Non-language symbols category
    #[allow(dead_code)]
    pub fn non_language_symbols() -> Vec<&'static str> {
        vec![
            "â’  â­’  â‹†   âŒ¯ á´— -  ð–¥»  %",
            "ã€„  â–¨  â–¦  â–©  â—Œ  â—  â—”  â—•  â€",
            " âœ¿  â  âœ¾  â–  â˜†  â˜…",
            "â–¡  â–   âœ®  âœ°  ï¼Ÿ ï¼ â  âˆ—  âœ¦  âœ§",
            " âŽ™  â€¹ðŸ¹  â€¹ðŸ¥  â™¡  â™¥ï¸Ž",
            "â˜ºï¸Ž  âŠ¹  â˜•ï¸Ž   à£ª Ë–",
            " â€º âŒ— â–¹ âš ï¸Ž",
            "â €â‘…â €â €âœ¦â €",
            "â €â‹†â €â¬ªâ €â €â•°â•®â €â™¡â €",
            "â¬ªË™     â €âŒ•â €âŠ¹ â €â €",
            "ï¹Ÿâ €â€¹ðŸ¹â €+â € ..",
            "âˆžâ €â €âŒ—â €â˜…â €â™¥ï¸Žâ €â­’â €Êš â™¡â €",
            "ï¹«â €â €ï¹ â €â €â—ªâ €ï¼â‹†",
            "  â–¦  â—â €â‰€â €",
            "ï¹— ðŸ’­",
            "â€¢ Ë–Ë“ â˜…  Ë–â–¸â—‚ â‹†  êœêœžâ——  Ë– à£ª â€¹",
            "â€¢ â€¢ â€¢ â€¢ â€¢",
            "â­“   â­” âˆž â– ",
            "â”„â”„â”„",
            "ï½¡ï¾Ÿï¾Ÿï½¥ï½¡ï½¥ï¾Ÿï¾Ÿï½¡",
            "ï¾Ÿã€‚",
            "ã€€ï¾Ÿï½¥ï½¡ï½¥ï¾Ÿ",
            "â—  â—¡ âŒ¦ âŒ« âŒž âŒ",
            ",, âœ°â˜…  ï½¥ï½¡",
            "â‡¡ â•´",
            " â†³ â†° âºâ—Ÿ âž¢",
            " â€¿ï¸µ â› âŠ° â‹±â‹°",
            "ï¸¿ ï¼Œï¼›â†»  .Â·Ë™Â·. â‡¾ ï¹",
            "â©© â—œâ— â—Ÿâ—ž",
            "â â âž ï¹«ï¸¶ âŸ†",
            "â¿»âŒ‡",
            "/) /)",
            "  â•°  â•¯ â•® â•­",
            "â¾â¾ â€§â‚Š",
            " â‘… â¥ ã€‚",
            "Ã—  áµŽáµŽ     â¿»  ãƒ»ï¼Žâ­” ï¸°",
            "âœ¦  êœœ  ï¼Ëšâ‚Š â€¹3ï¹’",
            "â§œ Ëƒ ï¸¿ Ë‚   ï¸µ âŠ¹",
            "ãƒ»âœ¿   â™¡ â€",
            "Ë¶ áµ”áµ” áµ•  á´—  /) /) ãƒ»",
            "ðŸŽ” ðŸŽ• ðŸ—¦ ðŸ—§",
            "ï¸° â¨    â¨ž    â¨Ÿ â¨¯",
        ]
    }


    /// Stylized box patterns from the gist - organized as (top, left_char, right_char, bottom)
    pub fn boxes() -> Vec<(&'static str, char, char, &'static str)> {
        vec![
            ("â”Žâ•Œâ•Œâ•¯â•°â•Œâ•Œâ”’", 'â”ƒ', 'â”ƒ', "â”–â•Œâ•Œâ•®â•­â•Œâ•Œâ”š"),
            ("â•­â”€â”€â”€â”€â•®", 'â”‚', 'â”‚', "â•°â”€â”€â”€â”€â•¯"),
            ("â”â—šâ—šâ—šâ—šâ—šâ—šâ—šâ—šâ—šâ—šâ—šâ—šâ”“", 'â”ƒ', 'â”ƒ', "â”—â—›â—›â—›â—›â—›â—›â—›â—›â—›â—›â—›â—›â”›"),
            ("â•”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•—", 'â•‘', 'â•‘', "â•šâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•"),
            ("â•­â•â”€â”€â”€â”€â•âŒ˜â•â”€â”€â”€â”€â•â•®", 'â”‚', 'â”‚', "â•°â•â”€â”€â”€â”€â•âŒ˜â•â”€â”€â”€â”€â•â•¯"),
            ("â”â”â”€â”€â”€â”€â•¯âŒ¬â•°â”€â”€â”€â”€â”â”“", 'â”ƒ', 'â”ƒ', "â”—â”â”€â”€â”€â”€â•®âŒ¬â•­â”€â”€â”€â”€â”â”›"),
            ("â•”â•â•â•â•âœ¦â–âœ¦â•â•â•â•â•—", 'â•‘', 'â•‘', "â•šâ•â•â•â•âœ¦â–âœ¦â•â•â•â•â•"),
            ("â”â”â”…â”…â”„â”„âŸžâŸ¦âœ®âŸ§âŸâ”„â”„â”‰â”‰â”â”“", 'â”ƒ', 'â”ƒ', "â”—â”â”…â”…â”„â”„âŸžâŸ¦âœ®âŸ§âŸâ”„â”„â”‰â”‰â”â”›"),
            ("â•”â•â•â•â•â–‘â‹† âœª â‹†â–‘â•â•â•â•â•—", 'â•‘', 'â•‘', "â•šâ•â•â•â•â–‘â‹† âœª â‹†â–‘â•â•â•â•â•"),
            ("â•­â”€â”€â”€â”€â”€ â€¢ â—ˆ â€¢ â”€â”€â”€â”€â”€â•®", 'â”‚', 'â”‚', "â•°â”€â”€â”€â”€â”€ â€¢ â—ˆ â€¢ â”€â”€â”€â”€â”€â•¯"),
            ("â”¯â”â”â”â”â” â—â—â— â”â”â”â”â”â”¯", 'â”ƒ', 'â”ƒ', "â”·â”â”â”â”â” â—â—â— â”â”â”â”â”â”·"),
            ("â•”â”€â”€â”€â”€â”€â”€Â¤â—ŽÂ¤â”€â”€â”€â”€â”€â”€â•—", 'â•‘', 'â•‘', "â•šâ”€â”€â”€â”€â”€â”€Â¤â—ŽÂ¤â”€â”€â”€â”€â”€â”€â•"),
            ("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“", 'â”ƒ', 'â”ƒ', "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"),
            ("â•­â”€â”€â”€â”€â”€â”€â”€â•¯â€¢â•°â”€â”€â”€â”€â”€â”€â”€â•®", 'â”‚', 'â”‚', "â•°â”€â”€â”€â”€â”€â”€â”€â•®â€¢â•­â”€â”€â”€â”€â”€â”€â”€â•¯"),
            ("â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••", 'â•‘', 'â•‘', "â•˜â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•›"),
            ("â•”â”€â”â”â”â”â”â” â˜… â”â”â”â”â”â”â”€â•—", 'â•‘', 'â•‘', "â•šâ”€â”â”â”â”â”â” â˜… â”â”â”â”â”â”â”€â•"),
            ("â•­â”â”€â”â”€â”â”€â‰ªâœ â‰«â”€â”â”€â”â”€â”â•®", 'â”‚', 'â”‚', "â•°â”â”€â”â”€â”â”€â‰ªâœ â‰«â”€â”â”€â”â”€â”â•¯"),
            ("â”Žâ”â”€â”â”€â”â”€â”â”€â”â”€â”â”€â”â”€â”â”€â”â”’", 'â”ƒ', 'â”ƒ', "â”–â”â”€â”â”€â”â”€â”â”€â”â”€â”â”€â”â”€â”â”€â”â”š"),
            ("â”â”€â”€â”â”€â”€â”â”€â”€â”™â—†â”•â”€â”€â”â”€â”€â”â”€â”€â”‘", 'â”ƒ', 'â”ƒ', "â”•â”€â”€â”â”€â”€â”â”€â”€â”‘â—†â”â”€â”€â”â”€â”€â”â”€â”€â”™"),
            ("â•”â•â•â•â”â”â”â”€â”€â”€ â€¢ â”€â”€â”€â”â”â”â•â•â•â•—", 'â•‘', 'â•‘', "â•šâ•â•â•â”â”â”â”€â”€â”€ â€¢ â”€â”€â”€â”â”â”â•â•â•â•"),
            ("â•”â•â•â•â•â•â•â•â•â•â•â€¢âŠ±âœ¦âŠ°â€¢â•â•â•â•â•â•â•â•â•â•â•—", 'â•‘', 'â•‘', "â•šâ•â•â•â•â•â•â•â•â•â•â€¢âŠ±âœ¦âŠ°â€¢â•â•â•â•â•â•â•â•â•â•â•"),
            ("â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®", 'â”‚', 'â”‚', "â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"),
            ("â”â”â”â”â”â€¢â…â€¢Â°â€¢âˆâ€¢Â°â€¢â…â€¢â”â”â”â”â”“", 'â”ƒ', 'â”ƒ', "â”—â”â”â”â”â€¢â…â€¢Â°â€¢âˆâ€¢Â°â€¢â…â€¢â”â”â”â”â”›"),
            ("â”Žâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆà­¨â™¡à­§â”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”’", 'â”ƒ', 'â”ƒ', "â”–â”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆà­¨â™¡à­§â”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”š"),
            ("â”â”â”â”â”â”Â°â€â€¢Â°:ðŸŽ€:Â°â€¢â€Â°â”â”â”â”â”â”“", 'â”ƒ', 'â”ƒ', "â”—â”â”â”â”â”Â°â€â€¢Â°:ðŸŽ€:Â°â€¢â€Â°â”â”â”â”â”â”›"),
            ("â”Œâ”€â”€â”€â”€â”€ â€¢âœ§âœ§â€¢ â”€â”€â”€â”€â”€â”", 'â”‚', 'â”‚', "â””â”€â”€â”€â”€â”€ â€¢âœ§âœ§â€¢ â”€â”€â”€â”€â”€â”˜"),
            ("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", 'â•‘', 'â•‘', "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"),
        ]
    }
}

/// Color palette for multi-color ASCII art
fn color_palette() -> Vec<fn(&str) -> ColoredString> {
    vec![
        |s| s.white(),
        |s| s.bright_white(),
        |s| s.cyan(),
        |s| s.bright_cyan(),
        |s| s.magenta(),
        |s| s.bright_magenta(),
        |s| s.yellow(),
        |s| s.bright_yellow(),
        |s| s.green(),
        |s| s.bright_green(),
    ]
}

/// Apply multi-color styling to ASCII art string
pub fn colorize_ascii_art(art: &str) -> String {
    let palette = color_palette();
    let mut result = String::new();
    let mut color_index = 0;

    for ch in art.chars() {
        if ch.is_whitespace() {
            result.push(ch);
        } else {
            let color_fn = palette[color_index % palette.len()];
            result.push_str(&color_fn(&ch.to_string()).to_string());
            color_index += 1;
        }
    }

    result
}

/// Random ASCII art selector
pub struct AsciiArtSelector {
    pub header: String,
    pub section: String,
}

impl AsciiArtSelector {
    /// Create a new selector with random choices from each category
    pub fn new() -> Self {
        let mut rng = rand::rng();
        
        let header_options = AsciiArtCategories::galactic_sparkles();
        let section_options = AsciiArtCategories::cute_sparkles();

        let header = header_options.choose(&mut rng)
            .map(|s| colorize_ascii_art(s))
            .unwrap_or_else(|| colorize_ascii_art("â‹‡â‹†âœ¦â‹†â‹‡ã€€ â‹‡â‹†âœ¦â‹†â‹‡"));
        
        let section = section_options.choose(&mut rng)
            .map(|s| colorize_ascii_art(s))
            .unwrap_or_else(|| colorize_ascii_art("â‹† Ëšï½¡â‹†à­¨à­§Ëšã€€Ëšà­¨à­§â‹†ï½¡Ëš â‹†"));

        Self {
            header,
            section,
        }
    }
}

/// Elegant text dividers (legacy support)
pub struct Dividers;

impl Dividers {
    /// Get random box pattern from gist
    /// Returns (top, left_char, right_char, bottom, width)
    pub fn box_pattern() -> (String, char, char, String, usize) {
        let mut rng = rand::rng();
        let boxes = AsciiArtCategories::boxes();
        
        let (top, left_char, right_char, bottom) = boxes.choose(&mut rng)
            .copied()
            .unwrap_or(boxes[0]);
        
        // Calculate width from the top line BEFORE colorizing (for accurate width)
        let width = top.chars().count();
        
        (
            colorize_ascii_art(top),
            left_char,
            right_char,
            colorize_ascii_art(bottom),
            width,
        )
    }
    
    /// Wrap text with decorative elements before and after
    pub fn decorate_text(text: &str) -> String {
        let mut rng = rand::rng();
        let decorations = vec!["âœ¦ âœ§ âœ¦", "âœ§ âœ¦ âœ§", "â˜† â˜… â˜†", "â˜… â˜† â˜…", "â‹† âœ§ â‹†", "âœ§ â‹† âœ§"];
        let decor = decorations.choose(&mut rng).unwrap_or(&"âœ¦ âœ§ âœ¦");
        format!("{} {} {}", decor, text, decor)
    }
}

/// Color helpers for white palette
pub struct Colors;

impl Colors {
    /// Section header color (very light gray/white)
    pub fn section(text: &str) -> ColoredString {
        text.white()
    }
}

/// Spinner styling with animated colors
pub fn spinner_template() -> String {
    // Spinner will have its own colors from frames, message is dimmed
    format!("{{spinner}} \x1b[2m{{msg}}\x1b[0m")
}

/// Generate animated spinner frames with random colors and characters
pub fn spinner_frames() -> Vec<String> {
    let mut rng = rand::rng();
    let characters = vec!["âœ¦", "âœ§", "â‹†", "â˜†", "â˜…", "âœ©", "âœª", "âœ«", "âœ¬", "âœ­", "âœ®", "âœ¯", "âœ°"];
    let palette = color_palette();
    
    let mut frames = Vec::new();
    for _ in 0..8 {
        let char = characters.choose(&mut rng).unwrap_or(&"âœ¦");
        let color_fn = palette.choose(&mut rng).unwrap();
        frames.push(color_fn(char).to_string());
    }
    
    frames
}
